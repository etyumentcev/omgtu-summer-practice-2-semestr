#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.DotNet.Interactive.Formatting;
using ScottPlot;

// Тест для BlockingCollection
(int, int, int) TestBlockingCollection()
{
    var collection = new BlockingCollection<int>();
    var readyToStart = new ManualResetEvent(false);
    var swTotal = new Stopwatch();
    var swEnqueue = new Stopwatch();
    var swDequeue = new Stopwatch();

    Thread producer = new Thread(() =>
    {
        readyToStart.WaitOne();
        swEnqueue.Start();
        for (int i = 0; i < 1000000; i++) { collection.Add(i); }
        swEnqueue.Stop();
        collection.CompleteAdding();
    });

    Thread consumer = new Thread(() =>
    {
        readyToStart.WaitOne();
        swDequeue.Start();
        while (!collection.IsCompleted)
        {
            if (collection.TryTake(out _)) { }
        }
        swDequeue.Stop();
    });

    producer.Start();
    consumer.Start();
    readyToStart.Set();
    swTotal.Start();

    producer.Join();
    consumer.Join();
    swTotal.Stop();

    return ((int)swTotal.ElapsedMilliseconds, (int)swEnqueue.ElapsedMilliseconds, (int)swDequeue.ElapsedMilliseconds);
}

// Тест для ConcurrentQueue
(int, int, int) TestConcurrentQueue()
{
    var queue = new ConcurrentQueue<int>();
    var readyToStart = new ManualResetEvent(false);
    var swTotal = new Stopwatch();
    var swEnqueue = new Stopwatch();
    var swDequeue = new Stopwatch();

    Thread producer = new Thread(() =>
    {
        readyToStart.WaitOne();
        swEnqueue.Start();
        for (int i = 0; i < 1000000; i++) { queue.Enqueue(i); }
        swEnqueue.Stop();
    });

    Thread consumer = new Thread(() =>
    {
        readyToStart.WaitOne();
        int result;
        swDequeue.Start();
        for (int i = 0; i < 1000000; i++)
        {
            while (!queue.TryDequeue(out result)) { }
        }
        swDequeue.Stop();
    });

    producer.Start();
    consumer.Start();
    readyToStart.Set();
    swTotal.Start();

    producer.Join();
    consumer.Join();
    swTotal.Stop();

    return ((int)swTotal.ElapsedMilliseconds, (int)swEnqueue.ElapsedMilliseconds, (int)swDequeue.ElapsedMilliseconds);
}

// Тест для обычной очереди
(int, int, int) TestQueue()
{
    var queue = new Queue<int>();
    var swTotal = new Stopwatch();
    var swEnqueue = new Stopwatch();
    var swDequeue = new Stopwatch();

    swTotal.Start();
    swEnqueue.Start();
    for (int i = 0; i < 1000000; i++) { queue.Enqueue(i); }
    swEnqueue.Stop();
    swDequeue.Start();
    for (int i = 0; i < 1000000; i++) { queue.Dequeue(); }
    swDequeue.Stop();
    swTotal.Stop();

    return ((int)swTotal.ElapsedMilliseconds, (int)swEnqueue.ElapsedMilliseconds, (int)swDequeue.ElapsedMilliseconds);
}

// Cбор результатов
(int[], int[]) Start(Func<(int, int, int)> testMethod, int iterations)
{
    int[] res = new int[iterations];
    int[] ite = new int[iterations];
    for (int i = 1; i < iterations + 1; i++)
    {
        (int total, int enqueue, int dequeue) = testMethod();
        res[i - 1] = total; // Записываем общее время
        ite[i - 1] = i; // Записываем номер итерации
    }
    return (ite, res);
}

#!csharp

#r "nuget:ScottPlot, 5.0.35"

using Microsoft.DotNet.Interactive.Formatting;
using System.Linq;

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(1200, 400)), HtmlFormatter.MimeType);

(int[] dataX1,int[] dataY1) = Start(TestBlockingCollection, 10);
(int[] dataX2,int[] dataY2) = Start(TestConcurrentQueue, 10);
(int[] dataX3,int[] dataY3) = Start(TestQueue, 10);

ScottPlot.Plot plt = new();
plt.Add.Scatter(dataX1, dataY1);
plt.Add.Scatter(dataX2, dataY2);
plt.Add.Scatter(dataX3, dataY3);

Console.WriteLine($"BlockingCollection: {dataY1.Average()}\nConcurrentQueue: {dataY2.Average()}\nНепотокобезопасные: {dataY3.Average()}");

plt

#!markdown

## Вывод
Средние результаты:
- BlockingCollection --- 207,6 ms
- ConcurrentQueue ---  10,9 ms
- Непотокобезопасный --- 13 ms

#!markdown

- ConcurrentQueue - намного эффективнее BlockingCollection и имеет преимущество над непотокобезопасными очередями. ConcurrentQueue на 13% эффективнее непотокобезопасной очереди.
- в потокобезопасных очередях время записи и чтения в среднем равны, у потоконебезпасной очереди - запись бывает намного дольше чтения.

#!csharp

using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

private const int Million = 1000000;

MeasurePerformance("BlockingCollection", RunBlockingCollection);
       
MeasurePerformance("ConcurrentQueue", RunConcurrentQueue);
        
MeasurePerformance("непотокобезопасный Queue", RunNonThreadSafeQueue);

    static void MeasurePerformance(string collectionName, Action action)
    {
        Console.WriteLine($"--- {collectionName} ---");

        for (int i = 0; i < 10; i++)
        {
            var stopwatch = Stopwatch.StartNew();
            action();
            stopwatch.Stop();

            Console.WriteLine($"Замер {i + 1}: {stopwatch.ElapsedMilliseconds} мс");
        }

        Console.WriteLine();
    }

    static void RunBlockingCollection()
    {
        var queue = new BlockingCollection<int>();

        // Запись
        var producerThread = new Thread(() =>
        {
            Stopwatch stopwatch = Stopwatch.StartNew();
            for (int i = 0; i < Million; i++)
            {
                queue.Add(i);
            }
            stopwatch.Stop();
            Console.WriteLine($"Время записи миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
        });

        producerThread.Start();
        producerThread.Join();

        // Чтение
        var consumerThread = new Thread(() =>
        {
            Stopwatch stopwatch = Stopwatch.StartNew();
            for (int i = 0; i < Million; i++)
            {
                queue.Take();
            }
            stopwatch.Stop();
            Console.WriteLine($"Время чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
        });

        consumerThread.Start();
        consumerThread.Join();
    }

    static void RunConcurrentQueue()
    {
        var queue = new ConcurrentQueue<int>();

        // Запись
        var producerThread = new Thread(() =>
        {
            Stopwatch stopwatch = Stopwatch.StartNew();
            for (int i = 0; i < Million; i++)
            {
                queue.Enqueue(i);
            }
            stopwatch.Stop();
            Console.WriteLine($"Время записи миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
        });

        producerThread.Start();
        producerThread.Join();

        // Чтение
        var consumerThread = new Thread(() =>
        {
            Stopwatch stopwatch = Stopwatch.StartNew();
            for (int i = 0; i < Million; i++)
            {
                int value;
                queue.TryDequeue(out value);
            }
            stopwatch.Stop();
            Console.WriteLine($"Время чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
        });

        consumerThread.Start();
        consumerThread.Join();
    }

    static void RunNonThreadSafeQueue()
    {
        var queue = new Queue<int>();

        Stopwatch stopwatch = Stopwatch.StartNew();

        // Запись
        for (int i = 0; i < Million; i++)
        {
            queue.Enqueue(i);
        }

        Console.WriteLine($"Время записи миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");

        stopwatch.Restart();

        // Чтение
        for (int i = 0; i < Million; i++)
        {
            queue.Dequeue();
        }

        Console.WriteLine($"Время чтения миллиона объектов: {stopwatch.ElapsedMilliseconds} мс");
    }
