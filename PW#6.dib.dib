#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №6. Изучение производительности потоко-безопасных очередей.

**Цель:** Определить лучшую потоко-безопасную коллекцию для выполнения интенсивной обработки входящих сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Назвать оптимальную коллекцию для обработки большого количества сообщений.
2. Изучите примтив синхронизации Условная переманная.


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Условные переменные Глава 5 п.5.1. книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования
3. [Одна из реализаций условных переменных на .Net](https://learn.microsoft.com/ru-ru/dotnet/api/system.threading.manualresetevent?view=net-8.0)

## Задание.
Исслдеовать производительность BlockingCollection и ConcurrentQueue в сравнении с непотокоабезопасной очередью.

Для каждой потоко-безопасной очереди необходимо реализовать 2 потока: один записывает объект в очередь, а другой - читает объект из очереди.
Для непотокобезопасной очереди реализовать два цикла - записи миллиона объектов в очередь и чтение миллиона объектов из очереди.

Необходимо определить два промежутка времени:
- время за которое поток или цикл обработает миллион объектов
- время, необходимое на запись и чтение миллиона объектов из очреди.

Сделать десять замеров по каждой коллекции. Все замеры показать на графике.

Записать в ноутбуке вывод - какая и потоко-безопасных коллекций эффективнее. И выразить в процентах - скорость самой быстрой поток-безопасной коллекции по сравнению с обычной очредью.

**Указание**.
1. Необходимо исключить из замеров время, необходимое для запуска и остановки потоков, то есть посчитать чистое время, необходимое для обработки объектов.
Для этого следует использовать условные события, которые позволят убедиться, что оба потока запустились и готовы читать и писать объекты и только потом запускать таймер.
2. Для итогового вывода сравнивать усредненные значения.

#!markdown

// здесь писать код

// BlockingCollection:
#r "nuget:ScottPlot, 5.0.36"
using Microsoft.DotNet.Interactive.Formatting;
using System.Collections.Concurrent;
using System.Threading;
using System.Diagnostics;

long[] ReadWr = new long[10];
long[] Read = new long[10];

for (int i = 0; i<10; i++){
BlockingCollection<object> blockcollect =  new BlockingCollection<object>();
ManualResetEvent ResStart = new ManualResetEvent(false);
ManualResetEvent ResComplete= new ManualResetEvent(false);
long countObject = 1000000;
bool a = true;
Thread threadW = new Thread(() =>
{
    ResStart.WaitOne();
    while(a)
        {
        if(countObject>0)
        {
                blockcollect.Add(new object());
                Interlocked.Decrement(ref countObject);
        }
        if(countObject == 0 && blockcollect.Count==0)
            a = false;
    }
});
Thread threadR = new Thread(() =>
{
    ResStart.WaitOne();
    Stopwatch WatchRead = Stopwatch.StartNew();
    while(a)   
        {
            if(blockcollect.Count != 0)
            {
                blockcollect.Take();
            }
        }
    ResComplete.Set();
    WatchRead.Stop();
    Read[i] = WatchRead.ElapsedMilliseconds;
});
threadW.Start();
threadR.Start();

ResStart.Set();

Stopwatch TimeReadWrite = Stopwatch.StartNew();
ResComplete.WaitOne();
TimeReadWrite.Stop();
threadW.Join();
threadR.Join();
ReadWr[i] = TimeReadWrite.ElapsedMilliseconds;
}
var ReadavverageFORBlockingCollection = Read.Average();
var ReadWriteavverageFORBlockingCollection = ReadWr.Average();

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
int[] numbers = Enumerable.Range(1,10).Select(x=>x).ToArray();
ScottPlot.Plot graph1 = new();
ScottPlot.Plot graph2 = new();
graph1.Add.Scatter(numbers, Read);
graph2.Add.Scatter(numbers, ReadWr);
Console.WriteLine("Время чтения: ");
graph1

#!csharp

Console.WriteLine("Время чтения + записи: ");
graph2

#!csharp

/// ConcurrentQueue:
#r "nuget:ScottPlot, 5.0.36"
using Microsoft.DotNet.Interactive.Formatting;
using System.Collections.Concurrent;
using System.Threading;
using System.Diagnostics;

long[] ReadWr = new long[10];
long[] Read = new long[10];
object obj = new object();
for (int i = 0; i<10; i++){
ConcurrentQueue<object> ConcurrentQueue = new ConcurrentQueue<object>();
ManualResetEvent ResStart = new ManualResetEvent(false);
ManualResetEvent ResComplete = new ManualResetEvent(false);
long countObj = 1000000;
bool a = true;
Thread threadW = new Thread(() =>
{
    ResStart.WaitOne();
    while(a)
        {
        if(countObj>0)
        {
                ConcurrentQueue.Enqueue(new object());
                Interlocked.Decrement(ref countObj);
        }
        if(countObj == 0 && ConcurrentQueue.Count==0)
            a = false;
    }
});
Thread threadR = new Thread(() =>
{
    ResStart.WaitOne();
    Stopwatch WatchRead = Stopwatch.StartNew();
    while(a)   
        {
            if(ConcurrentQueue.Count != 0)
            {
                ConcurrentQueue.TryDequeue(out obj);
            }
        }
    ResComplete.Set();
    WatchRead.Stop();
    Read[i] = WatchRead.ElapsedMilliseconds;
});
threadW.Start();
threadR.Start();

ResStart.Set();

Stopwatch TimeReadWr = Stopwatch.StartNew();
ResComplete.WaitOne();
TimeReadWr.Stop();
threadW.Join();
threadR.Join();
ReadWrite[i] = TimeReadWr.ElapsedMilliseconds;
}
var ReadavverageFORConcurrentQueue = Read.Average();
var ReadWriteavverageFORConcurrentQueue = ReadWrite.Average();

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
int[] numbers = Enumerable.Range(1,10).Select(x=>x).ToArray();
ScottPlot.Plot graph1 = new();
ScottPlot.Plot graph2 = new();
graph1.Add.Scatter(numbers, Read);
graph2.Add.Scatter(numbers, ReadWrite);
Console.WriteLine("Время чтения: ");
graph1

#!csharp

Console.WriteLine("Время чтения + записи: ");
graph2

#!csharp

/// Queue:
#r "nuget:ScottPlot, 5.0.36"

long[] ReadWrite = new long[10];
long[] Read = new long[10];

for (int i = 0; i < 10; i++){
  Queue<object> queue = new Queue<object>();
  Stopwatch WatchReadWrite = Stopwatch.StartNew();
  for(int j = 0; j<1000000; j++)
  {
        queue.Enqueue(new object());
  }
  Stopwatch WatchRead = Stopwatch.StartNew();
  for(int k = 0; k<1000000; k++)
    {
        queue.Dequeue();
    }
    WatchReadWrite.Stop();
    WatchRead.Stop();
    ReadWrite[i] = WatchReadWrite.ElapsedMilliseconds;
    Read[i] = WatchRead.ElapsedMilliseconds;
}
var ReadavverageFORQueue = Read.Average();
var ReadWriteavverageFORQueue = ReadWrite.Average();
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
int[] numbers = Enumerable.Range(1,10).Select(x=>x).ToArray();
ScottPlot.Plot graph1 = new();
ScottPlot.Plot graph2 = new();
graph1.Add.Scatter(numbers, Read);
graph2.Add.Scatter(numbers, ReadWrite);
Console.WriteLine("Время чтения: ");
graph1

#!csharp

Console.WriteLine("Время чтения + записи: ");
graph2

#!csharp

Console.WriteLine("Среднее время чтения и записи через BlockingCollection: {0} мс , через ConcurrentQueue: {1} мс, через Queue: {2} мс", ReadWriteavverageFORBlockingCollection, ReadWriteavverageFORConcurrentQueue, ReadWriteavverageFORQueue);

Console.WriteLine("Среднее время чтения через BlockingCollection: {0} мс , через ConcurrentQueue: {1} мс, через Queue: {2} мс", ReadavverageFORBlockingCollection, ReadavverageFORConcurrentQueue, ReadavverageFORQueue);

#!markdown

## Вывод
Потокобезопасная очередь ConcurrentQueue быстрее (средняя скорость 138.4 мс), чем BlockingCollection (средняя скорость 242.7 мс)
Непотокобезопасная очередь Queue соказалась быстрее всех (средняя скорость чтения 2.2 мс, чтения и записи 18.7 мс)
В чтении и записи Quene быстрее, чем ConcurrentQueue, в записи на 92,2%, в чтении на 98,5%
