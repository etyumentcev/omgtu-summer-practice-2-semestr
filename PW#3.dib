#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!csharp

using System;
using System.Threading;

class DefiniteIntegral
{
    private static double finalRes;
    private static Barrier barrier;

    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        finalRes = 0.0;
        var detailSteps = step / 3; 
        barrier = new Barrier(threadsnumber);
        var threads = new Thread[threadsnumber];
        

        for (int i = 0; i < threadsnumber; i++)
        {
            var threadIndex = i;
            threads[i] = new Thread(() =>
            {
                var lres = LocalResult(a, b, function, detailSteps, threadsnumber, threadIndex);
                Add(ref finalRes, lres);
                barrier.SignalAndWait();
            });
            threads[i].Start();
        }
        foreach (Thread thread in threads) thread.Join();

        return finalRes;
    }

    public static double LocalResult(double a, double b, Func<double, double> function, double step, int threadsnumber, int thread)
    {
        double localA = a + thread * (b - a) / threadsnumber;
        double localB = localA + (b - a) / threadsnumber;
        double localResult = 0.0;

        for (double x = localA; x < localB; x += step) localResult += (function(x) + function(x + step)) * step / 2.0;

        if (localB > b - step) localResult += (function(b - step) + function(b)) * step / 2.0;

        return localResult;
    }
    private static void Add(ref double finalRes, double value)
    {
        double currentValue0;
        double currentValue = finalRes;
        do
        {
            currentValue0 = currentValue + value;
        }
        while (Interlocked.CompareExchange(ref finalRes, currentValue0, currentValue) != currentValue);
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);
