#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;
using System.Diagnostics;

class DefiniteIntegral
{
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        int n = Convert.ToInt32((b - a) / step); // число шагов разбиения
        double sum = 0;
        Barrier barrier = new Barrier(threadsnumber);

        Parallel.For(0, threadsnumber, (i) =>
        {
            double subSum = 0;
            for (int j = i; j < n - 1; j += threadsnumber)
            {
                subSum += function(a + j * step) + function(a + (j + 1) * step);
            }
            subSum *= step / 2;
            Interlocked.Exchange(ref sum, sum + subSum);

            barrier.SignalAndWait();
        });

        return sum;
    }
}

#!markdown

Код ниже выполняется 1 минуту 25 секунд на Ryzen 7 3700x

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"

using Xunit;
using Microsoft.DotNet.Interactive.Formatting;


var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Stopwatch stopwatch = new Stopwatch();

double threadtime;
double minthreadtime = Double.MaxValue;
int minthreadnumber;
Dictionary<int, double> results = new Dictionary<int, double>();


Console.WriteLine("Промежуточный вывод:");

for(int threadnumber = 1; threadnumber <= 30; threadnumber++){
    threadtime = 0;
    for(int tests = 0; tests < 300; tests++){
        stopwatch.Reset();
        stopwatch.Start();
        double res = DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, threadnumber);
        Assert.Equal(0, res, 1e-4);
        stopwatch.Stop();
        threadtime += stopwatch.ElapsedTicks;
    }
    threadtime /= 300;
    if(threadtime < minthreadtime){
        minthreadtime = threadtime;
        minthreadnumber = threadnumber;
    } 
    results.Add(threadnumber, threadtime);
    Console.WriteLine(threadnumber + "\t" + threadtime);
}

Console.WriteLine("Оптимальное кол-во потоков: " + minthreadnumber + "\t Оптимальное время вычисления: " + minthreadtime);

Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(1600, 1200)), HtmlFormatter.MimeType);

ScottPlot.Plot plt = new();
plt.Add.Scatter(results.Values.ToArray(), results.Keys.ToArray());

plt

#!markdown

Код для однопоточного вычисления:

#!csharp

class TrapezoidalRule {
    public static double Solve(Func<double, double> f, double a, double b, double dx) {
        int number_of_steps = Convert.ToInt32((b - a)/dx);
        double delta_x = (b - a) / number_of_steps,
        result = 0;

        for(int i = 0; i < number_of_steps; i++){
            result += f(a + dx * i);
        }
        result *= delta_x;

        return result;
    }
}

#!csharp

using System.Diagnostics;

Func<double, double> f = (double x) => Math.Sin(x);
double answ = 0;
double timeonethread = 0;
for(int k = 0; k < 1000; k++){
    Stopwatch stopwatchsingle = new Stopwatch();
    stopwatchsingle.Start();
    answ += TrapezoidalRule.Solve(f, -100, 100, 1e-4);
    stopwatchsingle.Stop();
    timeonethread += stopwatchsingle.ElapsedTicks;
}
timeonethread /= 1000;
answ /= 1000;
Console.WriteLine("Ответ: " + answ + "\tВремя выполнения:" + timeonethread);

#!markdown

Summary:

Выбранный размер шага: 1e-4

Оптимальное количество потоков: 15

Время выполнения оптимальной многопоточной версии: 56641.04666666667 ticks

Время выполнения однопоточной версии: 247195.558 ticks

Сравнение времени выполнения оптимальной многопоточной версии с временем выполнения однопоточной версии: ~4,378 раз
