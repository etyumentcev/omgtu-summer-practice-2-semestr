#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

//
// Вычисление определенного интеграла
using System.Threading;
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsnumber)
    {
        // отсюда надо начинать реализацию задачи
        static bool Cheker(double x, double y)
        {
            return x - y > 1E-8;
        }
        if(!Cheker(b, a)) 
        {
            throw new Exception("Недопустимые входные данные");
        }
        double result = 0;
        Barrier barrier = new Barrier(threadsnumber + 1);

        for (int i = 0; i < threadsnumber; i++)
        {
            int threadIndex = i;
            ThreadPool.QueueUserWorkItem((q) =>
            {
                double partialResult = 0;
                for (double x = a + threadIndex * step; x < b; x += threadsnumber * step)
                {
                    partialResult += Math.Round((function(x) + function(x + step)) * step / 2, 7);
                }
                result += partialResult;
                barrier.SignalAndWait();
            });
        }
        barrier.SignalAndWait(); 
        return result;
    }

   public static double SolveOneThread(double a, double b, Func<double, double> function, double step)
    {
        double result = 0;
        double partialResult = 0;
                for (double x = a + step; x < b; x += step)
                {
                    result += Math.Round((function(x) + function(x + step)) * step / 2, 7);
                }
                result += Math.Round(partialResult, 5);
        return result;
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-4, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;
double ans = 0;
var SIN = (double x) => Math.Sin(x);
for (double i = 1e-1; i> 1e-7; i = i/10){
try{
    Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, i, 8), 1e-4);
    ans = i;
    break;
    } catch(Exception e){};
    
}
ans

#!csharp

using Microsoft.DotNet.Interactive.Formatting;
using System.Diagnostics;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(400, 300)), HtmlFormatter.MimeType);
    long[] longs = new long[10];
for (int i = 0; i<10; i++){
long Times = int.MaxValue;
int Potok = 0;
double Value = 0;
ScottPlot.Plot plt = new();
Stopwatch stopWatch = new Stopwatch();

 for (int threadsNumber = 1; threadsNumber <= 20; threadsNumber++)
        {
            stopWatch.Restart();
            double ParticalValue = 0;
            ParticalValue = DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, threadsNumber);
            stopWatch.Stop();
            if(Times > stopWatch.ElapsedMilliseconds)
            {
                Value = ParticalValue;
                Times = stopWatch.ElapsedMilliseconds;
                Potok = threadsNumber;
            }
            plt.Add.Scatter(stopWatch.ElapsedMilliseconds, threadsNumber);
        }
    longs[i] = Times;
}
double?average = longs.AsQueryable().Average();
Console.WriteLine("Наилучшее время выполенения: {0} за {1} потоков (значение: {2})", average, Potok, Value);
Console.WriteLine("Решение в один поток: " + DefiniteIntegral.SolveOneThread(-100, 100, SIN, 1e-4));
plt

#!csharp

using System.Diagnostics;
Stopwatch stopWatch = new Stopwatch();
long[] longs = new long[10];
for (int i = 0; i<10; i++){
stopWatch.Restart();
DefiniteIntegral.SolveOneThread(-100, 100, SIN, 1e-4);
stopWatch.Stop();
longs[i] = stopWatch.ElapsedMilliseconds;
}
double?average = longs.AsQueryable().Average();
average

#!markdown

Оптимальный размер шага был определён в 4 ячейке и составил 0,0001 (или 1e-4).

Оптимальное количество потоков было определено в 5 ячейке и составил 11 потоков, график составлен в той же ячейке.

Было сделано 10 замеров 11-ти поточного и однопоточного решения, был вычислен средний результат каждого. Для 11-ти поточного он составил 5 миллисекунд, для однопоточного 32 миллисекунды

Разница в эффективности по времени составляет 15,625%
