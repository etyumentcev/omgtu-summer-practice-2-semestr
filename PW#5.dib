#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №5. Идиома производитель-потребитель.

**Цель:** Изучить примитив синхронизации Очередь сообщений.

**Результаты:** После выполнения работы Вы сможете:
1. Передавать данные между потоками.
2. Изучите примитив синхронизации, который используется в современных архитектурах высоко-нагруженных приложений Event Loop


**Материалы для самостоятельного изучения**.
1. [Потоко-безопасные коллекции](https://learn.microsoft.com/en-us/dotnet/standard/collections/thread-safe/)
2. Идиома производитель-потребитель Глава 4 книги Г. Эндрюс Основы многопоточного, параллельного и распределенного программирования

## Задание.
Реализовать приложение Ping-Pong.

Создать два потока, каждый из которых в цикле читает данные из BlockingCollection<Message>. После того, как поток прочитал объект из очереди, вызвал его метод Handle(), он создает новый объект класса Message и записывает его в очередь другого потока. Каждый поток всего должен обработать 100 сообщений.

**Указание**.
1. Как запустить процесс обмена объектами Message между потоками? Первый объект Message пишем в очередь одного из потоков прямо из кода, коорый жти потоки стартовал.
2. Не забываем дождаться завершения работы потоков.

#!csharp

#r "nuget: xunit, 2.8.1"
using System.Threading;
using Xunit;

class Message
{
    static int messageHandled = 0;
    int id;
    public Message()
    {
        id = Thread.CurrentThread.ManagedThreadId;
    }

    public void Handle()
    {
        Interlocked.Increment(ref messageHandled);
        Assert.NotEqual(id, Thread.CurrentThread.ManagedThreadId);
    }

    public static void Check()
    {
        Assert.Equal(200, messageHandled);
    }
}

#!csharp

using System.Collections.Concurrent;
using System.Threading;

var Q1 = new BlockingCollection<Message>(2); //очередь первого потока
var Q2 = new BlockingCollection<Message>(2); //очередь второго потока
Barrier Bar = new Barrier(2);
Thread thread1 = new Thread(() =>  //Создал первый поток
{
    for (int i = 0; i < 100; i++)
    {
        Message Mes = Q1.Take();    //Читаем сообщение из очереди первого потока
        Mes.Handle();               //Обрабатывем сообщение
        {
            var newMes = new Message();     //Создаём новое сообщение и записываем его в очередь второго потока
            Q2.Add(newMes);
        }
    }
    Bar.SignalAndWait();
});
Thread thread2 = new Thread(() =>   //Создал второй поток
{
    int H2 = 0;
    for (int i = 0; i < 100; i++)
    {
        var Mes = Q2.Take();    //Читаем сообщение из очереди второго потока
        Mes.Handle();           //Обрабатывем сообщение
        H2++;
        if (H2!=100)
        {
            var newMes = new Message(); //Создаём новое сообщение и записываем его в очередь первого потока
            Q1.Add(newMes);
        }    
    }
    Bar.SignalAndWait();
});
Q1.Add(new Message());  //Создаём первое сообзение и записываем его в очередь первого потока
thread1.Start();    //Запуск потоков
thread2.Start();
Parallel.Invoke(()=>
{
    thread1.Join();
},
()=>
{
    thread2.Join();
});
// Здесь писать решение

#!csharp

Assert.Equal(0, Q1.Count);
Assert.Equal(0, Q2.Count);
Message.Check();
